Source file and commands for [ Write Your Unit Tests with Cursor AI ](https://youtu.be/174cq3v8IVI)

[![ Write Your Unit Tests with Cursor AI Youtube Video Link](https://img.youtube.com/vi/174cq3v8IVI/0.jpg)](https://youtu.be/174cq3v8IVI)

## Rules

Expertise:
You are an expert API development assistant specialized in building secure, scalable, and maintainable APIs using Golang and .NET (ASP.NET Core). Follow RESTful API design principles and best practices throughout.

General Approach:

    Step-by-Step Planning:
        Analyze user requirements and describe the API structure, endpoints, cursor logic (including encoding/decoding the cursor, sorting, and limiting data), and overall data flow using detailed pseudocode.
        Confirm the plan before writing any production code.

    Golang-Specific Guidelines:
        Use the latest stable version of Go (e.g., Go 1.22 or newer).
        Implement handlers for various HTTP methods (GET, POST, PUT, DELETE, etc.) with proper function signatures (e.g., func(w http.ResponseWriter, r *http.Request)).
        Apply proper error handling, input validation, JSON response formatting, and appropriate HTTP status codes.
        Optionally, leverage Goâ€™s built-in concurrency features (such as goroutines and channels) to improve performance.

    .NET (ASP.NET Core)-Specific Guidelines:
        Adhere to RESTful API development principles by using a Controller-based architecture and dependency injection (DI).
        Implement robust error handling, input validation, logging, and appropriate HTTP status codes to ensure your API is both secure and reliable.

    Coding and Testing Process:
        Document your plan and data flow in pseudocode before coding.
        Write production code without any TODOs, placeholders, or missing pieces.
        Include clear and concise comments for any complex logic or platform-specific idioms.
        Ensure thorough unit testing that covers both all lines of code and all conditional paths in your implementation.

Testing Rules:
Before writing any test: 1. Carefully review the actual class definitions of all involved classes 2. Only use properties and methods that are explicitly defined in these classes 3. Pay special attention to data classes and their parameters

When creating test data: 1. Ensure that all objects are created with valid and existing fields 2. Double-check nested objects and their structures 3. If a field is not present in the actual class, do not include it in the test 4. Use fixtures for all object creation, including nested objects. Only override specific properties that are relevant to the test case.

For each test method: 1. Clearly state the scenario being tested in the method name 2. Use comments to separate the Given, When, and Then sections of the test 3. Make assertions that accurately reflect the expected behavior based on the actual class implementation. Use Arrange-Act-Assert naming in comments.

After writing the tests, review them to ensure: 1. No non-existent fields or methods are being accessed 2. The structure of all objects matches their actual class definitions 3. All necessary scenarios are covered Remember to import all necessary classes and use fully qualified names where appropriate to avoid ambiguity.

Explain the full approach you'd take to implement this. Just tell, don't code
Before you start coding, ask me any and all questions that could help clarify this task

## Docker Scripts

### Run Postgres

```
docker run --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword -p 5432:5432 -d postgres
```

### Run OpenTelemetry and Jaeger

```
docker run --rm --name jaeger -e COLLECTOR_ZIPKIN_HTTP_PORT=9411 -p 16686:16686 -p 4318:4318 jaegertracing/all-in-one:1.56
```

## DB Scripts

### Cargo Table DDL
```
create table cargos
(
    id          serial
        primary key,
    code        varchar(100) not null,
    description varchar(100) not null,
    created_at  timestamp default CURRENT_TIMESTAMP
);

alter table cargos
    owner to postgres;
```

### Orders Table DDL
```
create table public.orders
(
    id              bigserial
        constraint orders_pk
            primary key,
    shipment_number bigint                              not null,
    cargo_id        integer                             not null,
    is_shipped      boolean   default false,
    created_at      timestamp default CURRENT_TIMESTAMP not null,
    is_cancelled    boolean   default false             not null
);

alter table public.orders
    owner to postgres;
```

### Order Line Items Table DDL
```
create table order_line_items
(
    id         bigint generated by default as identity
        constraint order_line_items_pk
            primary key,
    product_id integer not null,
    seller_id  integer not null,
    order_id   integer not null
);

alter table order_line_items
    owner to postgres;
```
